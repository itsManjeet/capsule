import "math.mod";

let Widget = fun (onDraw, onEvent) {
    self := {};

    self.Render = fun (ctxt, x, y, width, height) {
        self.x = x;
        self.y = y;
        self.width = width;
        self.height = height;

        onDraw(ctxt, x, y, width, height);

        self.Update = fun () {
            onDraw(ctxt, x, y, width, height);
        };
    };

    self.PollEvent = fun (event) {
        return onEvent(self, event);
    };
    return self;
};

let HORIZONTAL = 0;
let VERTICAL = 1;

let evalValue = fun (v, def) {
    if (v == null) { return def; }
    if (type(v) == closure) { return v(); }
    return v;
};

let Text = fun (data) {
    return Widget (fun (ctxt, x, y, width, height) {
        let text = evalValue(data.text, "No Text");
        let center = evalValue(data.center, true);

        let size = len(text);
    
        let ix = x;
        let iy = y;

        if (center) {
            ix = x + (width / 2) - len(text);
            iy = y + (height / 2);
        }

        for (ch in text) {
            if (ix >= width + x) {
                iy = iy + 1;
                ix = x;
            }

            if (iy >= height + y) {
                break;
            }

            ctxt.PutPixel(ix, iy, ch);
            ix = ix + 1;
        }

    }, fun (widget, event) {
        return false;
    });
};

let Box = fun (data) {
    return Widget (fun (ctxt, x, y, width, height) {
        let children = evalValue(data.children, []);
        let padding = evalValue(data.padding, 1);
        let spacing = evalValue(data.spacing, 1);
        let orientation = evalValue(data.orientation, HORIZONTAL);
        
        let count = len(children);

        ctxt.DrawRectangle(x, y, width, height);

        x = x + padding;
        y = y + padding;
        width = width - (padding * 2);
        height = height - (padding * 2);

        if (orientation == VERTICAL) {
            height = math.Round(height / count);
        } else {
            width = math.Round(width / count);
        }

        for (child in children) {
            child.Render(ctxt, x, y, width, height);

            if (orientation == VERTICAL) {
                y = y + height;
            } else {
                x = x + width;
            }
        }
    }, fun (widget, event) {
        let children = data.children or [];
        for (child in children) {
            if (child.PollEvent(event)) {
                return true;
            }
        }
    });
};


let Clickable = fun (data) {
    return Widget(fun (ctxt, x, y, width, height) {
        let child = evalValue(data.child, Box {});
        child.Render(ctxt, x, y, width, height);

    }, fun (widget, event) {
        let onEvent = data.onEvent or null;
        if (onEvent != null) {
            return onEvent(widget, event);
        }
    });
};


let Button = fun (data) {
    let state = {
        count: 0,
    };
    return Clickable {
        child: Box {
            orientation: HORIZONTAL,
            padding: 1,
            children: [
                Text { text: fun () { return str(state.count); }, },
            ],
        },
        onEvent: fun (widget, event) {
            if (event == "\n") {
                state.count = state.count + 1;
                return true;
            }
        },
    };
};